# -*- coding: utf-8 -*-
"""process_jsonlines.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12E24_kZjZsjK18LTPKH3aSQlca7BRFpN

# This is the preprocessing for the analysis
"""

from pathlib import Path
import os 

import pandas as pd 

PROJECT_ROOT = Path("/content/drive/MyDrive/zemi/realestate/")
os.chdir(PROJECT_ROOT)

DATAPATH = PROJECT_ROOT / "data"
SCRAPER_ROOT = DATAPATH / "scraper/scraper/data/data/"
SCRAPED_IMGS_ROOT = SCRAPER_ROOT / "imgs"

SITE_ROOT =  "https://realestate.yahoo.co.jp"
INPUT_FILE="more.jsonlines"

df = pd.read_json(SCRAPER_ROOT / INPUT_FILE, lines=True)



df.head()

df["b_no_floors"].unique()

df["b_no_floors"] = df["b_no_floors"].str.extract(r"(\d+)") # Extract number of floors from string

if df["apt_size"].apply(len).max() == 1 and isinstance(df["apt_size"].iloc[0], list):
   df["apt_size"] = df["apt_size"].str.join("")

df[["apt_style", "apt_size"]] = df["apt_size"].str.extract(r"(.*)<br>(.*)<sup>", expand=True)

# IF the price is not fixed, we take the lower of the two prices.
firsts = df["apt_rent"].apply(lambda x: x[0].split("～")[0])
if all(firsts.str.contains("万")):
    firsts = firsts.apply(lambda x: x.split("万")[0])
    firsts = firsts.astype("float")
    df["apt_rent"] = firsts

df["apt_detail_link"]

if df.apt_size.str.endswith("m").all():
    df["apt_size"] = df["apt_size"].str.slice(0, -1)
    df["apt_size"] = df["apt_size"].astype("float")

df["full_apt_detail_link"] = df["apt_detail_link"].apply(lambda x: SITE_ROOT+x)

df.loc[df["apt_admin_price"] == "5円", "full_apt_detail_link"].iloc[0] # There is one case with 5円 but it seems to be legit/ the poster made a mistake

import locale
locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')

df.loc[df["apt_admin_price"] == "なし", "apt_admin_price"] = "0円"
df["apt_admin_price"].str.contains("なし").any()

if not df["apt_admin_price"].str.contains("万").any():
    df["apt_admin_price"] = df.apt_admin_price.str.extract(r"(.*)円|0")
    df["apt_admin_price"] = df["apt_admin_price"].apply(lambda x: locale.atof(x) if not isinstance(x, float) else x)

df["apt_floor"] = df["apt_floor"].str.join("").apply(lambda x: float(x) if x is not "" else None).astype(float)

df["rel_image_paths"] = df["images"].apply(lambda x: x[0]["path"])

df["b_closest_stations"]

testdict = df["b_closest_stations"].iloc[0]

def get_closest(testdict):
    return next((k, v) for k, v in sorted( testdict.items(), key=lambda x: int(x[1][:-1])))

df[["station", "distance"]] = pd.DataFrame(df["b_closest_stations"].apply(lambda x: get_closest(x)).to_list(), columns=["station", "distance"])

df["distance"] = df["distance"].str.slice(0, -1).astype(float)

unused = ["apt_thanks_fee", "apt_deposit", "b_closest_stations", "b_address", "image_urls", "images", "full_apt_detail_link","apt_detail_link"] 
new_names =  ["_apt_thanks_fee", "_apt_deposit", "_b_closest_stations", "_b_address", "_image_urls", "_images", "_full_apt_detail_link","_apt_detail_link"] 
df = df.rename(dict(zip(unused, new_names)), axis="columns")

df.filter(regex=r"^[a-zA-Z].*", axis="columns")

OUTPUT_NAME = "filename.ar"
df.to_feather(DATAPATH / "processed" / OUTPUT_NAME)

pd.read_feather(DATAPATH / "processed" / OUTPUT_NAME)



